# API Reference

## Overview

Complete API reference for the Amoiq Chat Widget backend services.

## Base URL

All API requests go through the Gateway:
```
https://api-gateway.amoiq.com
```

## Authentication

### Gateway Authentication

All requests to Gateway require API key authentication:

```http
Authorization: Bearer <api-key>
```

### Backend Authentication

Backend services use JWT tokens (generated by Backend):

```http
Authorization: Bearer <jwt-token>
```

## Endpoints

### Message Endpoints

#### `POST /webchat/message`

Send a message (single endpoint for both anonymous and logged-in users).

**Request:**
```http
POST /webchat/message
Authorization: Bearer <api-key>
Content-Type: application/json

{
  "text": "Hello, I need help",
  "tenantId": "tenant-123",
  "sessionId": "session-789-abc123",
  "fingerprint": "a1b2c3d4e5f6g7h8",
  "userId": "user-456",              // Optional: If present = logged-in user
  "userInfo": {                      // Optional: Only for logged-in users
    "name": "John Doe",
    "email": "john@example.com",
    "phone": "+1234567890"
  },
  "domain": "example.com",
  "origin": "https://example.com",
  "url": "https://example.com/page",
  "referrer": "https://google.com",
  "siteId": "site-123"
}
```

**Response:**
```json
{
  "success": true,
  "messageId": "msg-123",
  "sessionId": "session-789-abc123"
}
```

**User Type Detection:**
- If `userId` present → Logged-in user
- If no `userId` → Anonymous user (uses sessionId + fingerprint)

#### `GET /api/chat/messages`

Fetch conversation history.

**Request:**
```http
GET /api/chat/messages?tenantId=xxx&sessionId=xxx&userId=xxx
Authorization: Bearer <jwt-token>
```

**Query Parameters:**
- `tenantId` (required): Tenant ID
- `sessionId` (optional): Session ID for anonymous users
- `userId` (optional): User ID for logged-in users

**Response:**
```json
{
  "messages": [
    {
      "id": "msg-123",
      "text": "Hello",
      "sender": "user",
      "timestamp": "2024-01-15T10:30:00.000Z",
      "sessionId": "session-456",
      "userId": "user-789"
    }
  ]
}
```

### Authentication Endpoints

#### `POST /api/chat/anonymous-token`

Generate JWT token for anonymous users.

**Request:**
```http
POST /api/chat/anonymous-token
Authorization: Bearer <api-key>
Content-Type: application/json

{
  "tenantId": "tenant-123"
}
```

**Response:**
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 3600
}
```

### Online Users Endpoints

#### `GET /api/chat/online-users`

Get list of online users for a tenant.

**Request:**
```http
GET /api/chat/online-users?tenantId=xxx
Authorization: Bearer <jwt-token>
X-Tenant-ID: tenant-123
```

**Response:**
```json
{
  "users": [
    {
      "userId": "user-123",
      "sessionId": "session-456",
      "connectedAt": "2024-01-15T10:30:00.000Z",
      "domain": "example.com",
      "origin": "https://example.com",
      "url": "https://example.com/page"
    }
  ]
}
```

## WebSocket API

### Connection

Connect to Gateway WebSocket endpoint:

```
wss://api-gateway.amoiq.com
```

**Connection Options:**
```javascript
{
  transports: ['websocket', 'polling'],
  query: {
    tenantId: 'tenant-123',
    role: 'admin'  // Optional: for admin connections
  },
  auth: {
    token: '<api-key>',  // API key for Gateway authentication
    role: 'admin'       // Optional: for admin connections
  }
}
```

### Events

#### Client → Server

**`message`** - Send a message
```typescript
{
  type: 'message',
  text: string,
  tenantId: string,
  sessionId: string,
  fingerprint: string,
  userId?: string,        // Optional: for logged-in users
  userInfo?: {            // Optional: for logged-in users
    name?: string,
    email?: string,
    phone?: string
  },
  domain?: string,
  origin?: string,
  url?: string,
  referrer?: string,
  siteId?: string,
  timestamp: string
}
```

**`get_online_users`** - Request online users list (admin only)
```typescript
{
  tenantId: string
}
```

#### Server → Client

**`meta_message_created`** - Message created notification
```typescript
{
  message: {
    id: string,
    text: string,
    sender: 'user' | 'bot' | 'agent',
    timestamp: string,
    sessionId: string,
    userId: string,
    tenantId: string
  }
}
```

**`user_online`** - User comes online (admin only)
```typescript
{
  userId: string,
  sessionId: string,
  connectedAt: string,
  domain?: string,
  origin?: string,
  url?: string
}
```

**`user_offline`** - User goes offline (admin only)
```typescript
{
  userId: string
}
```

**`online_users_list`** - Response to get_online_users
```typescript
{
  users: Array<{
    userId: string,
    sessionId: string,
    connectedAt: string,
    domain?: string,
    origin?: string,
    url?: string
  }>
}
```

## Error Responses

### Standard Error Format

```json
{
  "error": "Error message",
  "code": "ERROR_CODE",
  "details": {}
}
```

### HTTP Status Codes

- `200 OK` - Success
- `400 Bad Request` - Invalid request
- `401 Unauthorized` - Missing or invalid authentication
- `403 Forbidden` - Not authorized
- `404 Not Found` - Resource not found
- `500 Internal Server Error` - Server error

### Common Error Codes

- `INVALID_API_KEY` - Invalid API key
- `INVALID_JWT_TOKEN` - Invalid JWT token
- `MISSING_TENANT_ID` - Tenant ID is required
- `SESSION_NOT_FOUND` - Session not found
- `USER_NOT_FOUND` - User not found
- `RATE_LIMIT_EXCEEDED` - Rate limit exceeded

## Rate Limiting

- **HTTP API**: 100 requests per minute per IP
- **WebSocket**: 10 messages per second per connection
- **Rate limit headers**: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`

## Webhooks

The backend can send webhooks for message events. Configure webhook URL in backend settings.

**Webhook Payload:**
```json
{
  "event": "message.created",
  "timestamp": "2024-01-15T10:30:00.000Z",
  "data": {
    "messageId": "msg-123",
    "sessionId": "session-456",
    "userId": "user-789",
    "tenantId": "tenant-123",
    "text": "Hello",
    "senderType": "user"
  }
}
```

## Best Practices

1. **Always include sessionId and fingerprint** - Even for logged-in users
2. **Handle errors gracefully** - Implement retry logic with exponential backoff
3. **Use WebSocket for real-time** - Fallback to HTTP API if WebSocket unavailable
4. **Cache authentication tokens** - Don't request new token on every request
5. **Implement rate limiting** - Respect rate limits on client side
6. **Monitor connection status** - Handle disconnections gracefully

